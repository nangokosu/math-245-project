---
title: "Project proposal"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE,warning=F,message=F}
knitr::opts_chunk$set(echo = TRUE)
```

## Project proposal:
Our project seeks to use a variety of Gapminder country level statistics from 2016 to determine which variables correlate strongly with the overall level of happiness in a country (as measured by the Happiness Index), and how.

```{r}
library(tidyverse)
library(GGally)
library(ggplot2)
```


```{r}
df=readRDS("./merged_gapminder_happiness.rds")
df_variables=df%>%select(-country,-year)

#Remove all missing values
df1 <- subset(df, !is.na(df$parliament))
df1 <- subset(df1, !is.na(df1$hapiscore_whr))
df1 <- subset(df1, !is.na(df1$aged_15plus_unemployment_rate_percent))
df1 <- subset(df1, !is.na(df1$sanitation))
df1 <- subset(df1, !is.na(df1$right))
df1 <- subset(df1, !is.na(df1$edu))
df1 <- subset(df1, !is.na(df1$internetusers))
df1 <- subset(df1, !is.na(df1$sdi))
df1 <- subset(df1, !is.na(df1$hdiindex))
df1 <- subset(df1, !is.na(df1$forestcoverage))
df1 <- subset(df1, !is.na(df1$militaryexpenditure))
df1 <- subset(df1, !is.na(df1$mortality))
df1 <- subset(df1, !is.na(df1$wateraccess))
df1 <- subset(df1, !is.na(df1$broadband))
df1 <- subset(df1, !is.na(df1$agriculture))
df1 <- subset(df1, !is.na(df1$debt))
df1 <- subset(df1, !is.na(df1$gdppercapita_growth))
df1 <- subset(df1, !is.na(df1$foodinsecurity))
df1 <- subset(df1, !is.na(df1$exports))
df1 <- subset(df1, !is.na(df1$corruption))
df1 <- subset(df1, !is.na(df1$vaccine))
df1 <- subset(df1, !is.na(df1$incomeperperson))
```


```{r}
summary(df)
for(i in colnames(df_variables)) {
  hist = hist(na.omit(df_variables[[i]]), breaks = 20, main = paste("Distribution of", i),xlab=NULL)
}
```
```{r}
for(i in colnames(df_variables)) {
  boxplot = boxplot(na.omit(df_variables[[i]]), main = paste("Boxplot of", i),xlab=NULL)
}
```
```{r}
apply(df1[,3:24], 2, IQR)
apply(df1[,3:24], 2, var)
apply(df1[,3:24], 2, sd)
cor(df1[,3:24])
```

Description & distribution of each variable:
                         For each country:
parliament: Percentage of national parliamentary seats held by women. Lower and upper houses combined.
Distribution - skewed right, normal.

hapiscore_whr: This is the national average response to the question of life evaluations asking the following “Please imagine a ladder, with steps numbered from 0 at the bottom to 10 at the top. The top of the ladder represents the best possible life for you and the bottom of the ladder represents the worst possible life for you. On which step of the ladder would you say you personally feel you stand at this time?” This measure is also referred to as Cantril life ladder. Gapminder has converted this indicator's scale from 0 to 100 to easily communicate it in terms of percentage.
Distribution - mild hump/stretched-out normal curve with wide spread

aged_15plus_unemployment_rate_percent: Percentage of total population, age group above 15, that has been registered as unemployed during the given year.
Distribution - normal

right: Fundamental Rights in the form of liberal and social rights support both fair representation and the vertical 
mechanism of accountability that the first attribute seeks to achieve. This attribute is composed of three 
subattributes: access to justice, civil liberties, and social rights and equality. The three subattributes were 
aggregated into the Fundamental Rights index using BFA (source: Skaning 2019 via https://www.idea.int/gsod-indices/sites/default/files/idea-gsodi-2019-codebook-v3.pdf )
Distribution: normal/hump, wide spread

sanitation: percentage of people using improved sanitation facilities that are not shared with other households.
distribution - uniform/linear then with sharp jump/exponential increase at 100%.

hdiindex: Human Development Index (HDI) https://www.hdr.undp.org/en/content/human-development-index-hdi
distribution - concave down increasing, wide spread.

edu: Education index calculated based on Avg years of schooling, taking values 0 as minimum and 15 as maximum
Distribution - wide spread.

internetusers: Percentage of Population with stable Internet access
Distribution - multimodal, wide spread.

sdi: The Sustainable Development Index is an efficiency metric, designed to assess the ecological efficiency of nations in delivering human development. It is calculated as the quotient of two figures: (1) a “development index” based on the Human Development Index, calculated as the geometric mean of the life expectancy index, the education index, and a modified income index; and (2) an “ecological impact index” calculated as the extent to which consumption-based CO2 emissions and material footprint exceed per-capita shares of planetary boundaries.
Distribution - seemingly linearly increasing, or skewed left.

forestcoverage: Percentage of total land area that has been covered with forest
Distribution - Seemingly decreasing.

militaryexpenditure: Military expenditure as a percentage of GDP.
Distribution - Right skewed normal with outliers at larger values. 

mortality: Newborn mortality rate per 1000
Distribution - decreasing

wateraccess: Percentage of people with at least basic water services
Distribution - exponentially increasing.

broadband: Broadband subscribers per 100 people
Distribution - steep drop/potentially exponentially decreasing.

agriculture: Percentage of land area that is arable
Distribution - wide-ranging

debt: Total debt service (% of GNI)
Distribution - Sharp decrease then flat?

gdppercapita: GDP per capita
Distribution  - decreasing with outliers

foodinsecurity: Prevalence of moderate or severe food insecurity in the population
Distribution - normal skewed right?

Exports:% of GNP: exports of goods & services, include the value of merchandise, freight, insurance, transport, travel
Data source: https://data.worldbank.org/indicator/NE.EXP.GNFS.ZS

Corruption Perception Index (CPI): Transparency International's score of perceptions of corruption. Higher value indicates less corruption.
Data source: http://www.transparency.org/research/cpi

Income: Income per person adjusted for purchasing power
Data Source: World Bank, http:llgapm.io/dgdppc

Vaccine: Proportion of people who disagree that vaccines are effective for children to have
Data Source: http://gapm.io/dvaccine_confidence

## General observations 
There are some variables with significant left skew i.e beyond a certain threshold, the variable will most likely not affect the target variable any more (e.g water, sanitation).
There are some variables with significant right skew i.e below a certain threshold, the variable will most likely not affect the target variable any more (e.g debt).
There are a lot of variables with substantial numbers of missing values.

## knn imputation:
From our summary, we find that foodsecurity,vaccine and aged_15plus_unemployment_rate_percent have a high number of missing variables. However, in general, our dataset contains very few full entries (23). As such, we employ KNN imputation in order to 
fill in the missing entries.

```{r}
library(VIM)
df_variables_imputed=kNN(df_variables%>%select(-hapiscore_whr),k=10,imp_var=F)
df_variables_imputed['hapiscore_whr']=df_variables$hapiscore_whr
```

## checking knn imputation:

In order to see if our knn imputation significantly affects the relationship between variables that did not have a large number of missing entries, we compare the correlation plots before and after imputation.

```{r,fig.width=10}
ggcorr(df_variables%>%select(-hapiscore_whr,-foodinsecurity,-aged_15plus_unemployment_rate_percent),geom="circle",layout.exp = 1)+ggtitle("Before imputation")
ggcorr(df_variables_imputed%>%select(-hapiscore_whr,-foodinsecurity,-aged_15plus_unemployment_rate_percent),geom="circle",layout.exp = 1)+ggtitle("After imputation")
```

With knn imputation at k=10, the variable "right" is most affected, as its correlation with other variables was decreased from the imputation process. However, for reasons below, this will not be a problem.

```{r,fig.width=10}
ggcorr(df_variables_imputed%>%select(-hapiscore_whr),geom="circle",layout.exp = 1)+ggtitle("Full correlation matrix after imputation")
```

From the graph above, we see that the following variables are relatively independent from others: gdppercapita_growth,forestcoverage,sdi,aged_15plus_unemployment_rate_percent,parliament,vaccine.

Based on this distinction, we execute a two step process:
First, we do a regression of the happiness score based on these independent features to determine those with a statistically significant effect on the target.
Second, we do a PR decomposition of the remaining variables to eliminate the multicollinearity concerns, and use the PCs accounting for more than 80% of the total target variance for a PCR regression.
Finally, we do a PCR regression using the identified PCs alongside the independent features above.

## i 
```{r}
lm_independent=lm(hapiscore_whr~gdppercapita_growth+forestcoverage+sdi+aged_15plus_unemployment_rate_percent+parliament+vaccine,data=df_variables_imputed)
summary(lm_independent)
```

Based on the model, sdi and parliament are possible independent features. We also check for multicollinearity in the model with VIF, and see that our assumption of independence of feature variables is correct.

```{r}
car::vif(lm_independent)
```
## ii

```{r}
df_variables_remaining=df_variables_imputed%>%select(-gdppercapita_growth,-forestcoverage,-sdi,-aged_15plus_unemployment_rate_percent,-parliament,-hapiscore_whr,-vaccine)
pr_happiness=prcomp(df_variables_remaining,scale=T,center=T)
```

```{r}
pr_var=pr_happiness$sdev^2
prop_var=pr_var/sum(pr_var)
plot(cumsum(prop_var))
```

We decide to use 4 PCs, which account for 80% of the total variance.

```{r}
pr_pc=pr_happiness$x[,1:4]
pr_pc=cbind(pr_pc,df_variables_imputed%>%select(sdi,parliament))
pr_pc['hapiscore_whr']=df_variables$hapiscore_whr
model_pure_pcr=lm(hapiscore_whr~PC1+PC2+PC3+PC4,data=pr_pc)
model_pcr_additive=lm(hapiscore_whr~PC1+PC2+PC3+PC4+sdi+parliament,data=pr_pc)
summary(model_pcr_additive)
```
To see whether our independent features add any value to our PCR model, we conduct a model F-test using both. We see that the model with our independent variables along the PCs does not yield a better fit than the pure PCR model, so the latter is preferred. In fact, we may only need 3 PCs rather than 4.

```{r}
anova(model_pure_pcr,model_pcr_additive,test="F")
```
```{r,fig.width=10}
model_3_pcr=lm(hapiscore_whr~PC1+PC2+PC3,data=pr_pc)
par(mfrow=c(1,2))
plot(model_pure_pcr,which=c(1))
plot(model_pure_pcr,which=c(2))
```

Based on the diagnostics plot above, while our residuals do follow a normal distribution, there seems to be less variability at higher levels of the fitted values/predicted happiness scores. 

```{r}
na_criteria=is.na(df_variables_imputed$hapiscore_whr)
train_pr=pr_pc[!na_criteria,]
test_pr=pr_pc[na_criteria,]
set.seed(123)
lm_model_final_cv=train(hapiscore_whr~PC1+PC2+PC3,
      method="lm",
      data=train_pr,
      trControl=trainControl(method="cv",number=10))
```

```{r}
predictions_train=predict(lm_model_final_cv)
predictions_test=predict(lm_model_final_cv,newdata=test_pr)
test_pr$hapiscore_whr=predictions_test
```

Additionally, when combined with the result of the 10-fold CV regression model, our model appears to have bias. This indicates either high leverage values or possible missing covariates.

```{r,fig.width=10}
ggplot(data=NULL)+
  geom_density(aes(x=train_pr$hapiscore_whr,color="training set happiness score"))+
  geom_density(aes(x=predictions_train,color="training set fitted happiness score"))+
  geom_density(aes(x=test_pr$hapiscore_whr,color="test set predicted happiness score"))+
  theme_bw()+xlab("Happiness score")
```


## Implementation using Ridge regression:
Given multicollinearity is an issue as indicated by VIF, tolerance level, and correlation plot in our data, we decided to use Ridge Regression to further test our data. 
```{r}
y <- df1$hapiscore_whr
x <- data.matrix(df1[, 4:24])
library(glmnet)
model <- glmnet(x, y, alpha = 0)
summary(model)
cv_model <- cv.glmnet(x, y, alpha = 0)
best_lambda <- cv_model$lambda.min
best_lambda
plot(cv_model) 
best_model <- glmnet(x, y, alpha = 0, lambda = best_lambda)
coef(best_model)
plot(model, xvar = "lambda")
y_predicted <- predict(model, s = best_lambda, newx = x)
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
rsq <- 1 - sse/sst
rsq
```
